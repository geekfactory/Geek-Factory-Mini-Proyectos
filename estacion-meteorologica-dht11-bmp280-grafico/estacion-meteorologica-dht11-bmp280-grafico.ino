/**
  Geek Factory - "Dale vuelo a tus proyectos"
  www.geekfactory.mx

  PROYECTOS CON ARDUINO: ESTACIÓN METEOROLÓGICA CON ARDUINO - PROGRAMA EN MODO TEXTO
  ARDUINO PROJECTS: ARDUINO WHEATHER STATION - TEXT BASED PROGRAM

  CONSULTA EL ARCHIVO LICENCIA.TXT PARA CONOCER MÁS SOBRE LOS DERECHOS DE DISTRIBUCIÓN DE ESTE
  MATERIAL O LA SIGUIENTE URL: HTTPS://WWW.GEEKFACTORY.MX/LICENCIA-CONTENIDO.
  CHECK OUT THE LICENCE.TXT FILE TO LEARN MORE ABOUT THE DISTRIBUTION RIGHTS OF THIS WORK OR
  CHECK THE FOLLOWING URL: HTTPS://WWW.GEEKFACTORY.MX/LICENCIA-CONTENIDO.
  PUBLICADO BAJO LICENCIA ATTRIBUTION-NONCOMMERCIAL-SHAREALIKE 4.0 INTERNATIONAL (CC BY-NC-SA 4.0).
  PUBLISHED UNDER THE ATTRIBUTION-NONCOMMERCIAL-SHAREALIKE 4.0 INTERNATIONAL (CC BY-NC-SA 4.0)
  LICENCE.
  
  Resumen: Este programa implementa una estación meteorológica con Arduino usando los sensores
  DHT11 y BMP280. La lectura de estos sensores se muentra en una pantalla OLED de 128X64 pixeles.

  Overview: This program implements a basic weather station using Arduino and the DHT11 and BMP280
  sensors. The readings are displayed in a 128x64 pixles OLED display.
*/

#include <U8g2lib.h>
#include <Adafruit_BMP280.h>
#include <DHT.h>

/**
 * pin donde está conectado el sensor DHT11
 */
const int pinSensorHumedad = 3;

/**
 * Objeto para el sensor de presión barométrica y sensor de temperatura
 * la comunicación es por I2C.
 */
Adafruit_BMP280 barometro;

/**
 * Objeto para sensor de humedad y temperatura DHT11
 * El primer parámetro indica el pin donde se conecta el sensor
 * El segundo parámetro es el tipo de sensor (DHT11, DHT22, etc.)
 */
DHT higrometro(pinSensorHumedad, DHT11);

/**
 * Objeto para manejar la pantalla OLED I2C en modo gráfico, se utiliza
 * el parametro U8G2_R2 para rotar la pantalla de acuerdo a la posición
 * que usaremos en el Grove Beginner Kit.
 *
 * Este es el constructor para una pantalla OLED genérica basada en el
 * controlador SSD1306 de 128x64 pixeles. Se utiliza el módo 1 de memoria
 * buffer para ahorrar RAM, por lo que todas las operaciones de dibujo en
 * la pantalla deben realizarse dentro de un cíclo.
 */
U8G2_SSD1306_128X64_NONAME_1_HW_I2C oled(U8G2_R2);

/**
 * Variables de tipo float para almacenar la lectura de los sensores
 */
float presion = 0, temperatura = 0, humedad = 0;

/**
  * Mapa de bits del ícono de temperatura 54x54 pixeles, se almacena en la memoria de programa
  * (flash) gracias al uso del modificador PROGMEM.
  */
const unsigned char iconoTemperatura[] PROGMEM = {
  0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xe1, 0x01, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xc0,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x70, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70,
  0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03,
  0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70,
  0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03,
  0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x70, 0x8c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x78, 0x8c, 0x07, 0x00, 0x00, 0x00, 0x00,
  0x7c, 0x8c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0c,
  0x1c, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3f, 0x38, 0x00,
  0x00, 0x00, 0x00, 0x87, 0x7f, 0x38, 0x00, 0x00, 0x00, 0x80, 0xc3, 0xff, 0x70, 0x00, 0x00, 0x00,
  0x80, 0xc3, 0xff, 0x70, 0x00, 0x00, 0x00, 0x80, 0xc3, 0xff, 0x70, 0x00, 0x00, 0x00, 0x80, 0xc3,
  0xff, 0x70, 0x00, 0x00, 0x00, 0x00, 0x87, 0x7f, 0x70, 0x00, 0x00, 0x00, 0x00, 0x87, 0x7f, 0x38,
  0x00, 0x00, 0x00, 0x00, 0x07, 0x3f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x3c, 0x00, 0x00,
  0x00, 0x00, 0x1e, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00,
  0xf8, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0x00, 0x00, 0x00
};

/**
  * Mapa de bits del ícono de presión 54x54 pixeles, se almacena en la memoria de programa
  * (flash) gracias al uso del modificador PROGMEM.
  */
const unsigned char iconoPresion[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00,
  0x00, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xe1, 0x7f, 0x00, 0x00, 0x00,
  0xc0, 0x1f, 0x00, 0xfe, 0x00, 0x00, 0x00, 0xf0, 0x03, 0x00, 0xf0, 0x03, 0x00, 0x00, 0xf8, 0x01,
  0x00, 0xe0, 0x07, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x30, 0x3c, 0x00,
  0x00, 0x0f, 0x00, 0x00, 0x78, 0x3c, 0x00, 0x80, 0x07, 0x00, 0x00, 0x7c, 0x78, 0x00, 0x80, 0x03,
  0x00, 0x00, 0x3e, 0x70, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0xc0, 0x03, 0x00, 0x80,
  0x0f, 0xf0, 0x00, 0xc0, 0x01, 0x00, 0xc0, 0x07, 0xe0, 0x00, 0xe0, 0x01, 0x00, 0xfe, 0x03, 0xe0,
  0x01, 0xe0, 0x01, 0x80, 0xff, 0x01, 0xe0, 0x01, 0xe0, 0x01, 0x80, 0xff, 0x00, 0xe0, 0x01, 0xe0,
  0x00, 0xc0, 0xf3, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0xc0, 0xe1, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0xc0,
  0xe1, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0xc0, 0xf3, 0x00, 0xc0, 0x01, 0xe0, 0x01, 0xc0, 0x7f, 0x00,
  0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x7f, 0x00, 0xe0, 0x01, 0xe0, 0x01, 0xf0, 0x1f, 0x00, 0xe0, 0x01,
  0xc0, 0x01, 0xf8, 0x00, 0x00, 0xe0, 0x00, 0xc0, 0x03, 0x78, 0x00, 0x00, 0xf0, 0x00, 0xc0, 0x03,
  0x38, 0x00, 0x00, 0xf0, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x70, 0x00, 0x80, 0x07, 0x00, 0x00,
  0x00, 0x78, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x3c,
  0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00,
  0x7c, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0xf8, 0x01, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xf0, 0x03,
  0x00, 0xf0, 0x03, 0x00, 0x00, 0xc0, 0x1f, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x80, 0xff, 0xe1, 0x7f,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/**
  * Mapa de bits del ícono de humedad 54x54 pixeles, se almacena en la memoria de programa
  * (flash) gracias al uso del modificador PROGMEM.
  */
const unsigned char iconoHumedad[] PROGMEM = {
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xe0, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
  0xf1, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xe0, 0x03,
  0x00, 0x00, 0x00, 0x00, 0x7c, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xc0, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x3e, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x3e, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00,
  0x7e, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0xf8, 0x00,
  0x00, 0x00, 0xf0, 0x01, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf0, 0x01, 0x00, 0xf0, 0x01, 0x00, 0x00,
  0xf8, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x78, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c, 0x00,
  0x00, 0xc0, 0x07, 0x00, 0x00, 0x3c, 0xf0, 0x20, 0xc0, 0x07, 0x00, 0x00, 0x3e, 0x98, 0x31, 0x80,
  0x0f, 0x00, 0x00, 0x3e, 0x08, 0x19, 0x80, 0x0f, 0x00, 0x00, 0x1e, 0x08, 0x09, 0x80, 0x0f, 0x00,
  0x00, 0x1f, 0x98, 0x0d, 0x00, 0x1f, 0x00, 0x00, 0x1f, 0xf0, 0x04, 0x00, 0x1f, 0x00, 0x00, 0x1f,
  0x00, 0x06, 0x00, 0x1f, 0x00, 0x00, 0x1f, 0x00, 0xf3, 0x00, 0x1f, 0x00, 0x00, 0x1f, 0x00, 0x99,
  0x01, 0x1f, 0x00, 0x00, 0x3f, 0x80, 0x09, 0x01, 0x1f, 0x00, 0x00, 0x3f, 0x80, 0x08, 0x81, 0x1f,
  0x00, 0x00, 0x3f, 0xc0, 0x98, 0x81, 0x1f, 0x00, 0x00, 0x7e, 0x60, 0xf0, 0x80, 0x0f, 0x00, 0x00,
  0x7e, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0xfc, 0x00,
  0x00, 0xe0, 0x07, 0x00, 0x00, 0xfc, 0x01, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0x03, 0x00, 0xf8,
  0x03, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0xfc, 0x01, 0x00, 0x00, 0xf0, 0x3f, 0x00, 0xff, 0x00, 0x00,
  0x00, 0xe0, 0xff, 0xe1, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
  0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,
  0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0x00
};

/**
 * Prototipo de la función para dibujar las pantallas donde se muestran las mediciones
 * de nuestra estación meteorológica.
 */
void mostrarMedida(const uint32_t tiempo, const float valor, const char* unidades, const uint8_t* icono);

/**
 * Función setup: se ejecuta una vez cuando encendemos el arduino
 */
void setup() {
  Serial.begin(9600);
  Serial.println(F("-->  CURSO BASICO DE ARDUINO CON GROVE BEGINNER KIT <--"));
  Serial.println(F("-->         PROGRAMA ESTACIÓN METEOROLÓGICA         <--"));

  // preparar el display OLED
  oled.begin();

  // preparar el sensor DHT11 para su uso
  higrometro.begin();

  // preparar el sensor BMP280 para su uso
  if (!barometro.begin()) {
    Serial.println(F("Error: No se detecta sensor BMP280"));
    while (1)
      ;
  }

  // borrar la pantalla
  oled.clear();
  // configurar el tipo de letra para el mensaje inicial
  // se trata de una fuente de 12 pixeles de alto
  oled.setFont(u8g2_font_t0_12_tf);

  // inciar el cíclo de escritura de la pantalla
  oled.firstPage();
  // realizar todas las operaciones de dibujo dentro del ciclo
  do {
    // posicionar el cursor en la primera linea de la pantalla, estamos usando una fuente de 8 pixeles de alto
    oled.setCursor(0, 10);
    oled.print(F("Geek Factory"));
    // movemos el cursor a la siguiente línea, aumentando 10 pixeles
    oled.setCursor(0, 20);
    oled.print(F("Estacion"));
    oled.setCursor(0, 30);
    oled.print(F("Meteorologica"));
  } while (oled.nextPage());

  // configurar la fuente para escribir el resultado de las mediciones (usamos la version completa)
  oled.setFont(u8g2_font_VCR_OSD_tf);

  // mensaje para indicar que concluimos la función setup de forma satisfactoria
  Serial.println(F("Setup completado!"));

  // esperar un poco en la pantalla inicial
  delay(5000);
}

/**
 * Función loop: se ejecuta continuamente mientras el arduino permanece encendido
 */
void loop() {
  // leer el sensor de temperatura (BMP280)
  temperatura = barometro.readTemperature();
  // leer la presión atmosferica (BMP280) y convertir pascales a hectoPascales
  presion = barometro.readPressure() / 100;
  // leer la humedad relativa (DHT11)
  humedad = higrometro.readHumidity();

  // enviar las mediciones al monitor serial separadas por tabulaciones
  // ideal para utilizar con Serial Plotter
  Serial.print(temperatura, 1), Serial.print('t');
  Serial.print(presion, 1), Serial.print('t');
  Serial.println(humedad, 1);

  // mostrar la temperatura por 3 segundos
  mostrarMedida(3000, temperatura, "° C", iconoTemperatura);
  // mostrar la presion por 3 segundos
  mostrarMedida(3000, presion, "hPa", iconoPresion);
  // mostrar la humedad por 3 segundos
  mostrarMedida(3000, humedad, "% RH", iconoHumedad);
}

/**
 * Función implementada para dibujar la pantalla donde se muestran las mediciones.
 * Se implementa de esta forma para evitar un bucle para cada una de las mediciones.
 *
 * Recibe los siguientes parámetros:
 *
 * tiempo: Tiempo en milisegundos que permanecerá esta pantalla
 * valor: Valor a mostrar (float)
 * unidades: Cadena con las unidades y el símbolo o cualquier otra informacion a mostrar
 * icono: Bitmap a dibujar en pantalla
 */
void mostrarMedida(const uint32_t tiempo, const float valor, const char* unidades, const uint8_t* icono) {
  // borrar pantalla
  oled.clear();
  // inciar el cíclo de dibujo de la pantalla
  oled.firstPage();
  do {
    // coordenada para el valor de la medición
    oled.setCursor(60, 25);
    // imprimir el valor de la medición con un decimal de presición
    oled.print(valor, 1);
    // imprimir la cadena de unidades o información adicional
    oled.drawUTF8(60, 50, unidades);
    // dibujar el ícono correspondiente
    oled.drawXBMP(0, 5, 54, 54, icono);
  } while (oled.nextPage());  // avanzar a la siguiente pagina o salir del ciclo
    // esperar antes de mostrar la siguiente medida
  delay(tiempo);
}
